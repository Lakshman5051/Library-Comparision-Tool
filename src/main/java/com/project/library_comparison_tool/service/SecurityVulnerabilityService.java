package com.project.library_comparison_tool.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.project.library_comparison_tool.entity.Library;
import com.project.library_comparison_tool.entity.Vulnerability;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Service for detecting and storing security vulnerabilities
 * Uses OSV API (primary) + GitHub Advisories (fallback) + caching
 */
@Service
public class SecurityVulnerabilityService {

    private static final String OSV_API_URL = "https://api.osv.dev/v1/query";
    private static final String GITHUB_ADVISORIES_URL = "https://api.github.com/advisories";
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    private final String githubToken;
    
    // Simple in-memory cache (key: packageManager:packageName:version, value: List<Vulnerability>)
    private final Map<String, CacheEntry> cache = new HashMap<>();
    private static final long CACHE_DURATION_HOURS = 24; // Cache for 24 hours

    public SecurityVulnerabilityService(
            @Value("${github_api_token}") String githubToken) {
        this.githubToken = (githubToken != null && !githubToken.trim().isEmpty()) ? githubToken.trim() : null;
    }

    /**
     * Check and store vulnerabilities for a library
     * Returns list of Vulnerability entities to be persisted
     *
     * @param library Library to check
     * @return List of Vulnerability entities
     */
    public List<Vulnerability> checkAndStoreVulnerabilities(Library library) {
        if (library == null || library.getName() == null || library.getPackageManager() == null) {
            return new ArrayList<>();
        }

        String cacheKey = buildCacheKey(library);
        
        // Check cache first
        CacheEntry cached = cache.get(cacheKey);
        if (cached != null && !cached.isExpired()) {
            System.out.println("    → Using cached vulnerability data for " + library.getName());
            return deepCopyVulnerabilities(cached.vulnerabilities, library);
        }

        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        // Try OSV API first (primary source)
        try {
            List<Vulnerability> osvVulns = checkOsvApi(library);
            vulnerabilities.addAll(osvVulns);
        } catch (Exception e) {
            System.err.println("    ✗ Error checking OSV API for " + library.getName() + ": " + e.getMessage());
        }

        // Try GitHub Advisories if library has GitHub repo (fallback)
        if (library.getRepositoryUrl() != null && library.getRepositoryUrl().contains("github.com")) {
            try {
                List<Vulnerability> githubVulns = checkGitHubAdvisories(library);
                // Merge with OSV results (avoid duplicates)
                mergeVulnerabilities(vulnerabilities, githubVulns);
            } catch (Exception e) {
                System.err.println("    ✗ Error checking GitHub Advisories for " + library.getName() + ": " + e.getMessage());
            }
        }

        // Update library fields
        library.setVulnerabilityCount(vulnerabilities.size());
        library.setHasSecurityVulnerabilities(!vulnerabilities.isEmpty());

        // Cache results
        cache.put(cacheKey, new CacheEntry(vulnerabilities, System.currentTimeMillis()));

        if (!vulnerabilities.isEmpty()) {
            System.out.println("    → Found " + vulnerabilities.size() + " vulnerabilities for " + library.getName());
        }

        return vulnerabilities;
    }

    /**
     * Check OSV API for vulnerabilities
     */
    private List<Vulnerability> checkOsvApi(Library library) throws IOException {
        String ecosystem = mapToOsvEcosystem(library.getPackageManager());
        if (ecosystem == null) {
            return new ArrayList<>();
        }

        String packageName = normalizePackageNameForOsv(
                library.getPackageManager(),
                library.getName(),
                library.getPackageUrl()
        );

        if (packageName == null) {
            return new ArrayList<>();
        }

        // Build OSV query
        Map<String, Object> query = new HashMap<>();
        Map<String, String> packageInfo = new HashMap<>();
        packageInfo.put("name", packageName);
        packageInfo.put("ecosystem", ecosystem);
        query.put("package", packageInfo);
        
        if (library.getLatestVersion() != null) {
            query.put("version", library.getLatestVersion());
        }

        // Make POST request
        String jsonResponse = postJsonToUrl(OSV_API_URL, objectMapper.writeValueAsString(query));
        
        if (jsonResponse == null || jsonResponse.isEmpty()) {
            return new ArrayList<>();
        }

        JsonNode root = objectMapper.readTree(jsonResponse);
        List<Vulnerability> vulnerabilities = new ArrayList<>();

        if (root.has("vulns") && root.get("vulns").isArray()) {
            for (JsonNode vulnNode : root.get("vulns")) {
                Vulnerability vuln = parseOsvVulnerability(vulnNode, library);
                if (vuln != null) {
                    vulnerabilities.add(vuln);
                }
            }
        }

        return vulnerabilities;
    }

    /**
     * Parse OSV vulnerability response into Vulnerability entity
     */
    private Vulnerability parseOsvVulnerability(JsonNode vulnNode, Library library) {
        try {
            Vulnerability.VulnerabilityBuilder builder = Vulnerability.builder()
                    .library(library)
                    .source("OSV")
                    .lastChecked(LocalDate.now());

            // Vulnerability ID
            if (vulnNode.has("id")) {
                builder.vulnerabilityId(vulnNode.get("id").asText());
            }

            // Summary
            if (vulnNode.has("summary")) {
                builder.summary(vulnNode.get("summary").asText());
            } else if (vulnNode.has("details")) {
                String details = vulnNode.get("details").asText();
                builder.summary(details.length() > 200 ? details.substring(0, 200) + "..." : details);
            }

            // Details
            if (vulnNode.has("details")) {
                builder.details(vulnNode.get("details").asText());
            }

            // Severity
            if (vulnNode.has("severity") && vulnNode.get("severity").isArray()) {
                JsonNode severityArray = vulnNode.get("severity");
                if (severityArray.size() > 0) {
                    JsonNode severityNode = severityArray.get(0);
                    if (severityNode.has("score")) {
                        builder.cvssScore(severityNode.get("score").asText());
                    }
                    if (severityNode.has("type") && severityNode.get("type").asText().equals("CVSS_V3")) {
                        // Extract severity from CVSS score
                        String score = severityNode.has("score") ? severityNode.get("score").asText() : "";
                        builder.severity(extractSeverityFromCvss(score));
                    }
                }
            }

            // Affected versions
            if (vulnNode.has("affected") && vulnNode.get("affected").isArray()) {
                JsonNode affectedArray = vulnNode.get("affected");
                if (affectedArray.size() > 0) {
                    JsonNode affected = affectedArray.get(0);
                    if (affected.has("ranges") && affected.get("ranges").isArray()) {
                        JsonNode ranges = affected.get("ranges");
                        if (ranges.size() > 0) {
                            JsonNode range = ranges.get(0);
                            if (range.has("events") && range.get("events").isArray()) {
                                StringBuilder versionRange = new StringBuilder();
                                String fixedVersion = null;
                                
                                for (JsonNode event : range.get("events")) {
                                    if (event.has("introduced")) {
                                        versionRange.append(">=").append(event.get("introduced").asText());
                                    }
                                    if (event.has("fixed")) {
                                        fixedVersion = event.get("fixed").asText();
                                        versionRange.append(", <").append(fixedVersion);
                                    }
                                }
                                
                                builder.affectedVersionRange(versionRange.toString());
                                builder.fixedVersion(fixedVersion);
                            }
                        }
                    }
                }
            }

            // Published date
            if (vulnNode.has("published")) {
                try {
                    String published = vulnNode.get("published").asText();
                    builder.publishedDate(LocalDate.parse(published.substring(0, 10)));
                } catch (Exception e) {
                    // Ignore parsing errors
                }
            }

            // Modified date
            if (vulnNode.has("modified")) {
                try {
                    String modified = vulnNode.get("modified").asText();
                    builder.modifiedDate(LocalDate.parse(modified.substring(0, 10)));
                } catch (Exception e) {
                    // Ignore parsing errors
                }
            }

            // References
            if (vulnNode.has("references") && vulnNode.get("references").isArray()) {
                List<String> refs = new ArrayList<>();
                for (JsonNode ref : vulnNode.get("references")) {
                    if (ref.has("url")) {
                        refs.add(ref.get("url").asText());
                    }
                }
                builder.references(String.join(", ", refs));
            }

            return builder.build();
        } catch (Exception e) {
            System.err.println("    ✗ Error parsing OSV vulnerability: " + e.getMessage());
            return null;
        }
    }

    /**
     * Check GitHub Security Advisories API
     */
    private List<Vulnerability> checkGitHubAdvisories(Library library) throws IOException {
        // Extract owner/repo from repository URL
        String repoUrl = library.getRepositoryUrl();
        if (repoUrl == null || !repoUrl.contains("github.com")) {
            return new ArrayList<>();
        }

        Pattern pattern = Pattern.compile("github\\.com/([^/]+)/([^/]+)");
        Matcher matcher = pattern.matcher(repoUrl);
        if (!matcher.find()) {
            return new ArrayList<>();
        }

        String owner = matcher.group(1);
        String repo = matcher.group(2).replaceAll("\\.git$", "");

        // Query GitHub Advisories API
        String apiUrl = "https://api.github.com/repos/" + owner + "/" + repo + "/security-advisories";
        String jsonResponse = fetchJsonFromUrl(apiUrl);

        if (jsonResponse == null || jsonResponse.isEmpty()) {
            return new ArrayList<>();
        }

        JsonNode root = objectMapper.readTree(jsonResponse);
        List<Vulnerability> vulnerabilities = new ArrayList<>();

        if (root.isArray()) {
            for (JsonNode advisory : root) {
                Vulnerability vuln = parseGitHubAdvisory(advisory, library);
                if (vuln != null) {
                    vulnerabilities.add(vuln);
                }
            }
        }

        return vulnerabilities;
    }

    /**
     * Parse GitHub Advisory into Vulnerability entity
     */
    private Vulnerability parseGitHubAdvisory(JsonNode advisory, Library library) {
        try {
            Vulnerability.VulnerabilityBuilder builder = Vulnerability.builder()
                    .library(library)
                    .source("GitHub")
                    .lastChecked(LocalDate.now());

            if (advisory.has("ghsa_id")) {
                builder.vulnerabilityId(advisory.get("ghsa_id").asText());
            }

            if (advisory.has("summary")) {
                builder.summary(advisory.get("summary").asText());
            }

            if (advisory.has("description")) {
                builder.details(advisory.get("description").asText());
            }

            if (advisory.has("severity")) {
                builder.severity(advisory.get("severity").asText().toUpperCase());
            }

            if (advisory.has("published_at")) {
                try {
                    String published = advisory.get("published_at").asText();
                    builder.publishedDate(LocalDate.parse(published.substring(0, 10)));
                } catch (Exception e) {
                    // Ignore
                }
            }

            if (advisory.has("updated_at")) {
                try {
                    String updated = advisory.get("updated_at").asText();
                    builder.modifiedDate(LocalDate.parse(updated.substring(0, 10)));
                } catch (Exception e) {
                    // Ignore
                }
            }

            if (advisory.has("html_url")) {
                builder.references(advisory.get("html_url").asText());
            }

            return builder.build();
        } catch (Exception e) {
            System.err.println("    ✗ Error parsing GitHub advisory: " + e.getMessage());
            return null;
        }
    }

    /**
     * Normalize package name for OSV API
     * Handles Maven groupId:artifactId format
     */
    private String normalizePackageNameForOsv(String packageManager, String libraryName, String packageUrl) {
        if (packageManager == null || libraryName == null) {
            return null;
        }

        String upperPackageManager = packageManager.toUpperCase();

        // Maven needs groupId:artifactId format
        if ("MAVEN".equals(upperPackageManager) || "GRADLE".equals(upperPackageManager)) {
            // Try to extract groupId from packageUrl
            if (packageUrl != null && packageUrl.contains("mvnrepository.com")) {
                Pattern pattern = Pattern.compile("/artifact/([^/]+)/([^/]+)");
                Matcher matcher = pattern.matcher(packageUrl);
                if (matcher.find()) {
                    String groupId = matcher.group(1);
                    return groupId + ":" + libraryName;
                }
            }
            // Fallback: return just artifactId (may work for some packages)
            return libraryName;
        }

        // For other package managers, use name as-is
        return libraryName;
    }

    /**
     * Map package manager to OSV ecosystem
     */
    private String mapToOsvEcosystem(String packageManager) {
        if (packageManager == null) return null;

        switch (packageManager.toUpperCase()) {
            case "NPM": return "npm";
            case "PYPI": return "pypi";
            case "MAVEN":
            case "GRADLE": return "maven";
            case "NUGET": return "nuget";
            case "CARGO":
            case "CRATES": return "cargo";
            case "GO": return "go";
            case "RUBYGEMS": return "rubygems";
            case "PACKAGIST":
            case "COMPOSER": return "packagist";
            case "COCOAPODS": return "cocoapods";
            case "HEX": return "hex";
            default: return null;
        }
    }

    /**
     * Extract severity from CVSS score
     */
    private String extractSeverityFromCvss(String cvssScore) {
        try {
            // Extract numeric score from CVSS string
            Pattern pattern = Pattern.compile("(\\d+\\.\\d+)");
            Matcher matcher = pattern.matcher(cvssScore);
            if (matcher.find()) {
                double score = Double.parseDouble(matcher.group(1));
                if (score >= 9.0) return "CRITICAL";
                if (score >= 7.0) return "HIGH";
                if (score >= 4.0) return "MEDIUM";
                return "LOW";
            }
        } catch (Exception e) {
            // Ignore
        }
        return "UNKNOWN";
    }

    /**
     * Merge vulnerabilities, avoiding duplicates by vulnerability ID
     */
    private void mergeVulnerabilities(List<Vulnerability> existing, List<Vulnerability> newVulns) {
        Set<String> existingIds = new HashSet<>();
        for (Vulnerability vuln : existing) {
            if (vuln.getVulnerabilityId() != null) {
                existingIds.add(vuln.getVulnerabilityId());
            }
        }

        for (Vulnerability vuln : newVulns) {
            if (vuln.getVulnerabilityId() == null || !existingIds.contains(vuln.getVulnerabilityId())) {
                existing.add(vuln);
            }
        }
    }

    /**
     * Build cache key
     */
    private String buildCacheKey(Library library) {
        return library.getPackageManager() + ":" + library.getName() + ":" + 
               (library.getLatestVersion() != null ? library.getLatestVersion() : "latest");
    }

    /**
     * Deep copy vulnerabilities for caching
     */
    private List<Vulnerability> deepCopyVulnerabilities(List<Vulnerability> source, Library library) {
        List<Vulnerability> copy = new ArrayList<>();
        for (Vulnerability vuln : source) {
            Vulnerability copyVuln = Vulnerability.builder()
                    .library(library)
                    .vulnerabilityId(vuln.getVulnerabilityId())
                    .summary(vuln.getSummary())
                    .details(vuln.getDetails())
                    .severity(vuln.getSeverity())
                    .cvssScore(vuln.getCvssScore())
                    .affectedVersionRange(vuln.getAffectedVersionRange())
                    .fixedVersion(vuln.getFixedVersion())
                    .publishedDate(vuln.getPublishedDate())
                    .modifiedDate(vuln.getModifiedDate())
                    .source(vuln.getSource())
                    .references(vuln.getReferences())
                    .lastChecked(vuln.getLastChecked())
                    .build();
            copy.add(copyVuln);
        }
        return copy;
    }

    /**
     * Fetch JSON from URL (GET) with optional GitHub token authentication
     */
    private String fetchJsonFromUrl(String urlString) {
        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setRequestProperty("Accept", "application/json");
            connection.setRequestProperty("User-Agent", "LibraryComparisonTool/1.0");
            
            // Add GitHub token if this is a GitHub API call and token is available
            if (urlString.contains("api.github.com") && githubToken != null && !githubToken.isEmpty()) {
                connection.setRequestProperty("Authorization", "token " + githubToken);
            }
            
            connection.setConnectTimeout(5000);
            connection.setReadTimeout(5000);

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                Scanner scanner = new Scanner(connection.getInputStream());
                scanner.useDelimiter("\\A");
                String response = scanner.hasNext() ? scanner.next() : "";
                scanner.close();
                return response;
            } else if (responseCode == 403 || responseCode == 401) {
                // Silently fail for GitHub API auth issues (advisories might not need auth)
                return null;
            }
            return null;
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * POST JSON to URL
     */
    private String postJsonToUrl(String urlString, String jsonBody) {
        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");
            connection.setDoOutput(true);
            connection.setConnectTimeout(5000);
            connection.setReadTimeout(10000);

            // Write request body
            connection.getOutputStream().write(jsonBody.getBytes());

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                Scanner scanner = new Scanner(connection.getInputStream());
                scanner.useDelimiter("\\A");
                String response = scanner.hasNext() ? scanner.next() : "";
                scanner.close();
                return response;
            }
            return null;
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * Cache entry with expiration
     */
    private static class CacheEntry {
        List<Vulnerability> vulnerabilities;
        long timestamp;

        CacheEntry(List<Vulnerability> vulnerabilities, long timestamp) {
            this.vulnerabilities = vulnerabilities;
            this.timestamp = timestamp;
        }

        boolean isExpired() {
            long now = System.currentTimeMillis();
            return (now - timestamp) > (CACHE_DURATION_HOURS * 60 * 60 * 1000);
        }
    }
}

